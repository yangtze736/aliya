#!/usr/bin/env bash
# shellcheck source=/dev/null disable=2178,2128
#
# Tests for the Pure Bash Bible.


test_split() {
    IFS=$'\n' read -d "" -ra result < <(split "hello,world,my,name,is,john" ",")
    assert_equals "${result[*]}" "hello world my name is john"
}

assert_equals() {
    if [[ "$1" == "$2" ]]; then
        ((pass+=1))
        status=$'\e[32m✔'
    else
        ((fail+=1))
        status=$'\e[31m✖'
        local err="(\"$1\" != \"$2\")"
    fi

    printf ' %s\e[m | %s\n' "$status" "${FUNCNAME[1]/test_} $err"
}

main() {
    trap 'rm readme_code test_file' EXIT

    # Extract code blocks from the README.
    while IFS=$'\n' read -r line; do
        [[ "$code" && "$line" != \`\`\` ]] && printf '%s\n' "$line"
        [[ "$line" =~ ^\`\`\`sh$ ]] && code=1
        [[ "$line" =~ ^\`\`\`$ ]]   && code=
    done < README.md > readme_code

    # Run shellcheck and source the code.
    shellcheck -s bash readme_code test.sh build.sh || exit 1
    . readme_code

    head="-> Running tests on the Pure Bash Bible.."
    printf '\n%s\n%s\n' "$head" "${head//?/-}"

    # Generate the list of tests to run.
    IFS=$'\n' read -d "" -ra funcs < <(declare -F)
    for func in "${funcs[@]//declare -f }"; do
        [[ "$func" == test_* ]] && "$func";
    done

    comp="Completed $((fail+pass)) tests. ${pass:-0} passed, ${fail:-0} failed."
    printf '%s\n%s\n\n' "${comp//?/-}" "$comp"

    # If a test failed, exit with '1'.
    ((fail>0)) || exit 0 && exit 1
}

main "$@"
